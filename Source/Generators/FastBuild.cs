using System;
using System.Collections.Generic;
using System.IO;
using BCT.Source.Model;

namespace BCT.Source.Generators
{
    //
    // Сортирует проекты по порядку использования
    //  очень жЫрный алгоритм, ~O^3
    //
    public class ProjectSorter
    {
        List<ProjectFile> sortedProjects = new List<ProjectFile>();

        public ProjectSorter()
        {
        }

        int GetProjectIndex(ProjectFile proj)
        {
            for (int i = 0; i < sortedProjects.Count; i++ )
            {
                if (sortedProjects[i].CompareTo(proj) == 0)
                {
                    return i;
                }
            }

            return -1;
        }

        public void Add(ProjectFile proj)
        {
            int projIndex = GetProjectIndex(proj);
            if (projIndex < 0)
            {
                sortedProjects.Add(proj);
                projIndex = sortedProjects.Count - 1;
            }

            List<ProjectFile> movedProjects = new List<ProjectFile>();

            foreach (ProjectFile refProj in proj.ReferencedCppProjects)
            {
                int refIndex = GetProjectIndex(refProj);
                if (refIndex < 0)
                {
                    sortedProjects.Insert(projIndex, refProj);
                }
                else
                {
                    if (refIndex > projIndex)
                    {
                        sortedProjects.RemoveAt(refIndex);
                        sortedProjects.Insert(projIndex, refProj);
                        projIndex++;

                        movedProjects.Add(refProj);
                    }
                }
            }



            //check
            int _projIndex = GetProjectIndex(proj);
            if (_projIndex < 0)
                throw new Exception("Bad");
            foreach (ProjectFile refProj in proj.ReferencedCppProjects)
            {
                int _refIndex = GetProjectIndex(refProj);
                if (_refIndex < 0)
                    throw new Exception("Bad");

                if (_refIndex > _projIndex)
                    throw new Exception("Bad");
            }

            //снова добавляем проекты, которые сдвинули (их зависимости нужно тоже подвинуть)
            foreach (ProjectFile movedProj in movedProjects)
            {
                Add(movedProj);
            }
            

        }


        public List<ProjectFile> SortedProjects { get { return sortedProjects; } }

        
    }


	public class GeneratorFastBuild2 : IGenerator
	{

        public static string GetProjectFullPath(Workspace workSpace, ProjectFile project)
        {
            var location = Utilites.FixupSlashes(workSpace.ResolveMacroVariables(project.location));
            if (string.IsNullOrEmpty(location))
                location = Utilites.GetTargetDirectory() + project.GetType().Name + "/";

            var projFullPath = location + project.GetType().Name + ".bff";

            return projFullPath;
        }

        void GenerateCompilerSettings()
        {
            #region
            using (var memoryStream = new MemoryStream())
            {

                using (var output = new StreamWriter(memoryStream))
                {
                    output.WriteLine("; autogenerated fasbuild compiler settings");
                    output.WriteLine("");

                    output.WriteLine("; Visual Studio Settings");
                    output.WriteLine(".VSBasePath = \"c:/Program Files (x86)/Microsoft Visual Studio 10.0\"");
                    output.WriteLine(".WindowsSDKBasePath = \"c:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A\"");
                    output.WriteLine("");

                    output.WriteLine("; Settings");
                    output.WriteLine("Settings");
                    output.WriteLine("{");

                    output.WriteLine("  .Environment = { \"PATH=$VSBasePath$/Common7/IDE/;$VSBasePath$/VC/bin/\",");
                    output.WriteLine("                   \"TMP=C:/Windows/Temp\", ");
                    output.WriteLine("                   \"SystemRoot=C:/Windows\" }");

                    output.WriteLine("}");
                    output.WriteLine("");


                    output.WriteLine("; Compiler");
                    output.WriteLine("Compiler( 'MSVC-2010' )");
                    output.WriteLine("{");
                    output.WriteLine("  .VCRoot = '$VSBasePath$/VC/bin'");
                    output.WriteLine("  .Executable = '$VCRoot$/cl.exe'");
                    output.WriteLine("  .ExtraFiles = { '$VCRoot$/c1.dll',");
                    output.WriteLine("                  '$VCRoot$/c1xx.dll',");
                    output.WriteLine("                  '$VCRoot$/c2.dll',");
                    output.WriteLine("                  '$VCRoot$/1033/clui.dll',");
                    output.WriteLine("                  '$VSBasePath$/VC/redist/x86/Microsoft.VC100.CRT/msvcp100.dll',");
                    output.WriteLine("                  '$VSBasePath$/VC/redist/x86/Microsoft.VC100.CRT/msvcr100.dll' }");
                    output.WriteLine("}");
                    output.WriteLine("");


                    output.WriteLine("; Build configuration");
                    output.WriteLine(".BaseConfig =");
                    output.WriteLine("[");

                    output.WriteLine("  .CompilerOptions = '\"%1\" /c'");
                    output.WriteLine("                   + ' /D\"_CRT_SECURE_NO_WARNINGS\"'");
                    output.WriteLine("                   + ' /D\"_UNICODE\" /D\"UNICODE\"'");
                    output.WriteLine("                   + ' /D\"_WINDLL\"'");
                    output.WriteLine("                   + ' /Z7'                                                             ; Produces an .obj file containing full symbolic debugging information for use with the debugger");
                    output.WriteLine("                   + ' /nologo'                                                         ; Suppress Startup Banner");
                    output.WriteLine("                   + ' /W4'                                                             ; Warning level 4");
                    output.WriteLine("                   + ' /MP'                                                             ; Compiles multiple source files by using multiple processes");
                    output.WriteLine("                   + ' /Oy-'                                                            ; Suppresses creation of frame pointers on the call stack (No)");
                    output.WriteLine("                   + ' /GF'                                                             ; Enables string pooling");
                    output.WriteLine("                   + ' /Gm-'                                                            ; Enables minimal rebuild (No)");
                    output.WriteLine("                   + ' /arch:SSE2'                                                      ; Architecture for code generation : SSE2");
                    output.WriteLine("                   + ' /fp:fast'                                                        ; Floating-point behavior : Fast");
                    output.WriteLine("                   + ' /Zc:wchar_t'                                                     ; Parse wchar_t as a built-in type");
                    output.WriteLine("                   + ' /Zc:forScope'                                                    ; Set for loop's initializer visibility");
                    output.WriteLine("                   + ' /GR'                                                             ; Enable Run-Time Type Information");
                    output.WriteLine("                   + ' /Gd'                                                             ; Uses the __cdecl calling convention");
                    output.WriteLine("                   + ' /bigobj'                                                         ; Increase Number of Sections in .obj file");
                    output.WriteLine("");


                    output.WriteLine("  .CompilerDebugOptions = ' /WX-'                                                       ; Treats all compiler warnings as errors (None)");
                    output.WriteLine("                        + ' /Od'                                                        ; Disables optimization");
                    output.WriteLine("                        + ' /RTC1'                                                      ; Run-time error checks");
                    output.WriteLine("                        + ' /MDd'                                                       ; Using debug multithreaded DLL using MSVCRTD.lib");
                    output.WriteLine("                        + ' /GS'                                                        ; Buffer Security Check");
                    output.WriteLine("                        + ' /D\"_DEBUG\"'");
                    output.WriteLine("");

                    output.WriteLine("  .CompilerReleaseOptions = ' /WX'                                                      ; Treats all compiler warnings as errors");
                    output.WriteLine("                          + ' /Ox'                                                      ; Uses maximum optimization");
                    output.WriteLine("                          + ' /Ob2'                                                     ; Inline Function Expansion");
                    output.WriteLine("                          + ' /Oi'                                                      ; Generate Intrinsic Functions");
                    output.WriteLine("                          + ' /Ot'                                                      ; Favors fast code");
                    output.WriteLine("                          + ' /MD'                                                      ; Creates a multithreaded DLL using MSVCRT.lib");
                    output.WriteLine("                          + ' /GS-'                                                     ; Buffer Security Check");
                    output.WriteLine("                          + ' /Gy'                                                      ; Enables function-level linking");
                    output.WriteLine("                          + ' /D\"_RELEASE\"'");
                    output.WriteLine("");


                    output.WriteLine("  .PCHOptions = .CompilerOptions");
                    output.WriteLine("              + ' /Fp\"%2\" /Fo\"%3\"'");

                    output.WriteLine("  .CompilerOptions + ' /Fo\"%2\"'");

                    output.WriteLine("  .LibrarianOptions = ' /NOLOGO /OUT:\"%2\" \"%1\"'");
                    output.WriteLine("  .LibrarianDebugOptions = ' /WX:NO'");
                    output.WriteLine("  .LibrarianReleaseOptions = ' /WX '");

                    output.WriteLine("  .LinkerOptions = '/OUT:\"%2\" \"%1\"'");
                    output.WriteLine("                 + ' /LIBPATH:\"$VSBasePath$/VC/lib\"\'");
                    output.WriteLine("                 + ' /LIBPATH:\"$WindowsSDKBasePath$/Lib\"\'");
                    output.WriteLine("                 + ' /NOLOGO'                                                            ; Suppress Startup Banner");
                    output.WriteLine("                 + ' /TLBID:1'                                                           ; Resource ID (default = 1)");
                    output.WriteLine("                 + ' /DYNAMICBASE'                                                       ; Dynamic base address");
                    output.WriteLine("                 + ' /NXCOMPAT'                                                          ; Windows Data Execution Prevention compatible");
                    output.WriteLine("                 + ' kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib'");
                    output.WriteLine("");

                    output.WriteLine("  .LinkerDebugOptions = ' /WX:NO'                                                  ; Treat Linker Warnings as Errors: NO");
                    output.WriteLine("                      + ' /DEBUG'                                                  ; Creates debugging information");
                    output.WriteLine("                      + ' /INCREMENTAL'                                            ; Enable incremental linking");
                    output.WriteLine("");

                    output.WriteLine("  .LinkerReleaseOptions = ' /WX'                                                   ; Treat Linker Warnings as Errors: YES'");
                    output.WriteLine("                        + ' /OPT:REF'                                              ; Eliminates functions and data that are never referenced");
                    output.WriteLine("                        + ' /OPT:ICF'                                              ; Perform identical COMDAT folding");
                    output.WriteLine("                        + ' /INCREMENTAL:NO'                                       ; Disable incremental linking");
                    output.WriteLine("");

                    output.WriteLine("  .BaseIncludePaths = ' /I\"./\"'");
                    output.WriteLine("                    + ' /I\"$VSBasePath$/VC/include\"'");
                    output.WriteLine("                    + ' /I\"$WindowsSDKBasePath$/include\"'");
                    output.WriteLine("                    + ' /I\"$WindowsSDKBasePath$/include/um\"'");
                    output.WriteLine("                    + ' /I\"$WindowsSDKBasePath$/include/shared\"'");

                    output.WriteLine("  .CompilerOptions + .BaseIncludePaths");
                    output.WriteLine("  .PCHOptions + .BaseIncludePaths");

                    output.WriteLine("  .ToolsBasePath = '$VSBasePath$/VC/bin'");
                    output.WriteLine("  .Compiler = 'MSVC-2010'");
                    output.WriteLine("  .Librarian = '$ToolsBasePath$/lib.exe'");
                    output.WriteLine("  .Linker = '$ToolsBasePath$/link.exe'");

                    output.WriteLine("]");
                    output.WriteLine("");



                    output.WriteLine("; x86 specific");
                    output.WriteLine(".BaseConfig_Win32 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig )");
                    output.WriteLine("  .LinkerOptions + ' /MACHINE:X86'");
                    output.WriteLine("  .Platform = 'x86'");
                    output.WriteLine("]");
                    output.WriteLine("");


                    output.WriteLine("; x64 specific");
                    output.WriteLine(".BaseConfig_x64 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig )");
                    output.WriteLine("  .LinkerOptions + ' /MACHINE:X64'");
                    output.WriteLine("  .Platform = 'x64'");
                    output.WriteLine("]");
                    output.WriteLine("");



                    output.WriteLine("; Debug configuration x86");
                    output.WriteLine(".DebugConfig_Win32 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_Win32 )");
                    output.WriteLine("  .Config = 'Debug'");
                    output.WriteLine("  .CompilerOptions + .CompilerDebugOptions");
                    output.WriteLine("  .PCHOptions + .CompilerDebugOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianDebugOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerDebugOptions");
                    output.WriteLine("]");
                    output.WriteLine("");

                    output.WriteLine("; Profile configuration x86");
                    output.WriteLine(".ProfileConfig_Win32 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_Win32 )");
                    output.WriteLine("  .Config = 'Release'");
                    output.WriteLine("  .CompilerOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .PCHOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianReleaseOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerReleaseOptions");
                    output.WriteLine("]");
                    output.WriteLine("");

                    output.WriteLine("; Release configuration x86");
                    output.WriteLine(".ReleaseConfig_Win32 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_Win32 )");
                    output.WriteLine("  .Config = 'Release'");
                    output.WriteLine("  .CompilerOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .PCHOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianReleaseOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerReleaseOptions");
                    output.WriteLine("]");
                    output.WriteLine("");

                    output.WriteLine("; FinalRelease configuration x86");
                    output.WriteLine(".FinalReleaseConfig_Win32 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_Win32 )");
                    output.WriteLine("  .Config = 'Release'");
                    output.WriteLine("  .CompilerOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .PCHOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianReleaseOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerReleaseOptions");
                    output.WriteLine("]");
                    output.WriteLine("");

                  
                    output.WriteLine("; Debug configuration x64");
                    output.WriteLine(".DebugConfig_x64 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_x64 )");
                    output.WriteLine("  .Config = 'Debug'");
                    output.WriteLine("  .CompilerOptions + .CompilerDebugOptions");
                    output.WriteLine("  .PCHOptions + .CompilerDebugOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianDebugOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerDebugOptions");
                    output.WriteLine("]");
                    output.WriteLine("");

                    output.WriteLine("; Profile configuration x64");
                    output.WriteLine(".ProfileConfig_x64 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_x64 )");
                    output.WriteLine("  .Config = 'Release'");
                    output.WriteLine("  .CompilerOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .PCHOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianReleaseOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerReleaseOptions");
                    output.WriteLine("]");
                    output.WriteLine("");


                    output.WriteLine("; Release configuration x64");
                    output.WriteLine(".ReleaseConfig_x64 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_x64 )");
                    output.WriteLine("  .Config = 'Release'");
                    output.WriteLine("  .CompilerOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .PCHOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianReleaseOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerReleaseOptions");
                    output.WriteLine("]");
                    output.WriteLine("");

                    output.WriteLine("; FinalRelease configuration x64");
                    output.WriteLine(".FinalReleaseConfig_x64 =");
                    output.WriteLine("[");
                    output.WriteLine("  Using( .BaseConfig_x64 )");
                    output.WriteLine("  .Config = 'Release'");
                    output.WriteLine("  .CompilerOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .PCHOptions + .CompilerReleaseOptions");
                    output.WriteLine("  .LibrarianOptions + .LibrarianReleaseOptions");
                    output.WriteLine("  .LinkerOptions + .LinkerReleaseOptions");
                    output.WriteLine("]");
                    output.WriteLine("");


                    output.WriteLine("; Resource compiler");
                    output.WriteLine(".ResourceCompiler =");
                    output.WriteLine("[");
                    output.WriteLine("  .Compiler = '$WindowsSDKBasePath$/Bin/x86/RC.exe'");
                    output.WriteLine("  .CompilerOutputExtension = '.res'");
                    output.WriteLine("  .CompilerOptions = '/nologo /fo\"%2\" \"%1\"'");
                    output.WriteLine("]");
                    output.WriteLine("");



                    output.Flush();

                    var fileName = Utilites.GetTargetDirectory() + "vs2010.bff";
                    Utilites.SaveFileIfChanged(fileName, memoryStream);
                }
            }
            #endregion
        }


        static public bool HaveSourceFilesToBuild(List<ProjectFile> projectConfigurations, string location)
        {
            foreach (var project in projectConfigurations)
            {
                IEnumerable<string> files = project.GetFiles(location);
                foreach (string file in files)
                {
                    var fileType = Utilites.GetFileType(file);

                    if (fileType == Utilites.FileType.SOURCE)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

		public bool BuildProject( Workspace workSpace, List<ProjectFile> projectConfigurations )
		{
            var projectName = projectConfigurations[0].GetType().Name;
            var location = Utilites.FixupSlashes(workSpace.ResolveMacroVariables(projectConfigurations[0].location));

            var relativeLocation = Utilites.RelativePath(Utilites.GetTargetDirectory(), location);

            if (HaveSourceFilesToBuild(projectConfigurations, location) == false)
            {
                return true;
            }

            #region
            using (var memoryStream = new MemoryStream())
            {
                using (var output = new StreamWriter(memoryStream))
                {
                    bool needUnityBuild = projectConfigurations[0].UseUnityBuild;

                    output.WriteLine("; autogenerated fasbuild project");
                    output.WriteLine("");

                    output.WriteLine(".ProjectRoot = \"$Root$\\{0}\"", relativeLocation.TrimEnd('/', '\\'));

                    foreach (var project in projectConfigurations)
                    {
                        var _intermediateDir = Utilites.RelativePath(Utilites.GetTargetDirectory(), workSpace.ResolveMacroVariables(Utilites.GetTargetDirectory() + project.intermediateDirectory));
                        var _outputDirectory = Utilites.RelativePath(Utilites.GetTargetDirectory(), workSpace.ResolveMacroVariables(Utilites.GetTargetDirectory() + project.outputDirectory));

                        output.WriteLine(".Temp = \"$Root$\\{0}\"", _intermediateDir.TrimEnd('/', '\\'));
                        output.WriteLine(".Out = \"$Root$\\{0}\"", _outputDirectory.TrimEnd('/', '\\'));

                        string configuration = Utilites.GetConfigurationName(project.configuration);
                        string platform = Utilites.GetPlatformName(project.platform);

                        string fullName = projectName + "-" + configuration + "-" + platform;
                        string configName = configuration + "Config_" + platform;

                        // define LIB
                        //--------------------------------------------------------

                        if (project.applicationKind == ApplicationKind.STATIC_LIBRARY)
                        {
                            output.WriteLine("Library( '{0}-in' )", fullName);
                        }
                        else
                        {
                            output.WriteLine("ObjectList( '{0}-in' )", fullName);
                        }

                        output.WriteLine("{");
                        output.WriteLine("  Using( .{0} )", configName);

                        if (project.usePrecompiledHeaders)
                        {
                            //precompiled headers
                            output.WriteLine("  .PCHInputFile = '$ProjectRoot$\\stdafx.cpp'");
                            output.WriteLine("  .PCHOutputFile = '$Temp$\\{0}.pch'", projectName);
                            output.WriteLine("  .CompilerOptions + ' /Yu\"stdafx.h\" /Fp\"$PCHOutputFile$\"'");
                            output.WriteLine("  .PCHOptions + ' /Yc\"stdafx.h\"'");
                        }

                        //output path
                        output.WriteLine("  .CompilerOutputPath = '$Temp$'");
                        output.WriteLine("  .LibrarianOutput = '$Temp$\\{0}.lib'", projectName);


                        IEnumerable<string> projectConfigurationFiles = project.GetFiles(location);

                        ICollection<FileDesc> files = new List<FileDesc>();
                        foreach (string fileName in projectConfigurationFiles)
                        {
                            FileDesc fileDesc = new FileDesc();
                            fileDesc.fileName = fileName;
                            fileDesc.config.includedConfigurations.Add(project);
                            files.Add(fileDesc);
                        }

                        if (needUnityBuild)
                        {
                            Log.Info(string.Format("Unity build for {0}|{1}|{2}", projectName, configuration, platform));
                            
                            //нужно сгенерировать Unity Build
                            files = UnityBuild.Create(
                                files,
                                location,
                                projectConfigurations[0].MaxFilesInOneUnity,
                                projectConfigurations[0].UnityBuildIngoreList,
                                project.usePrecompiledHeaders,
								project.language);
                        }
                        else
                        {
                            UnityBuild.Cleanup(location);
                        }


                        //input files root
                        output.WriteLine("  .CompilerInputFilesRoot = '$ProjectRoot$\\'");

                        //input files
                        output.WriteLine("  .CompilerInputFiles	= {");


                        bool needComma = false;
                        foreach (FileDesc file in files)
                        {
                            //этот файл компилировать в данной конфигурации не нужно
                            if (file.config.includedConfigurations.Count <= 0 || file.config.includedConfigurations[0] != project)
                            {
                                continue;
                            }

                            var fileType = Utilites.GetFileType(file.fileName);

                            if (fileType != Utilites.FileType.SOURCE)
                            {
                                continue;
                            }

                            if (Utilites.IsPrecompiledHeaderFile(file.fileName))
                            {
                                continue;
                            }

                            if (needComma)
                            {
                                output.WriteLine(",");
                            }
                            output.Write("                          '$ProjectRoot$\\{0}'", file.fileName);
                            needComma = true;
                        }
                        output.WriteLine("");
                        output.WriteLine("                        }");
                        output.WriteLine("");


                        //additional include dirs
                        for (int i = 0; i < project.IncludeDirs.Count; i++ )
                        {
                            string relativeIncludeDir = Utilites.RelativePath(Utilites.GetTargetDirectory(), workSpace.ResolveMacroVariables(project.IncludeDirs[i]));

                            if (i == 0)
                            {
                                output.WriteLine("  .AdditionalIncludePaths = ' /I\"{0}\"'", relativeIncludeDir);
                            }
                            else
                            {
                                output.WriteLine("                          + ' /I\"{0}\"'", relativeIncludeDir);
                            }
                        }

                        output.WriteLine("");
                        
                        //defines
                        for (int i = 0; i < project.Defines.Count; i++)
                        {
                            if (i == 0)
                            {
                                output.WriteLine("  .AdditionalDefines = ' /D\"{0}\"'", project.Defines[i]);
                            }
                            else
                            {
                                output.WriteLine("                     + ' /D\"{0}\"'", project.Defines[i]);
                            }
                        }

                        if (needUnityBuild)
                        {
                            if (project.Defines.Count == 0)
                            {
                                output.WriteLine("  .AdditionalDefines = ' /D\"UNITY_BUILD_ENABLED=1\"'");
                            }
                            else
                            {
                                output.WriteLine("                     + ' /D\"UNITY_BUILD_ENABLED=1\"'");
                            }
                        }

                        output.WriteLine("");
                        output.WriteLine("  .CompilerOptions + .AdditionalIncludePaths");
                        output.WriteLine("  .PCHOptions + .AdditionalIncludePaths");
                        output.WriteLine("  .CompilerOptions + .AdditionalDefines");
                        output.WriteLine("  .PCHOptions + .AdditionalDefines");

                        output.WriteLine("}");
                        output.WriteLine("");

                        string nameForAlias = fullName + "-in";

                        bool isExecutable = project.applicationKind == ApplicationKind.WINDOWED_APPLICATION || project.applicationKind == ApplicationKind.CONSOLE_APPLICATION;

                        if (isExecutable)
                        {
                            // define EXE
                            //--------------------------------------------------------
                            nameForAlias = fullName + "-exe";
                            output.WriteLine("Executable( '{0}' )", nameForAlias);
                        }
                        else
                        {
                            // define DLL
                            //--------------------------------------------------------
                            nameForAlias = fullName + "-dll";
                            output.WriteLine("DLL( '{0}' )", nameForAlias);
                        }


                        if (project.applicationKind != ApplicationKind.STATIC_LIBRARY)
                        {
                            output.WriteLine("{");
                            output.WriteLine("  Using( .{0} )", configName);
                            output.Write("  .Libraries = { \"" + fullName + "-in\"");

                            SortedSet<ProjectFile> referencedProjects = project.ReferencedCppProjects;
                            foreach (ProjectFile refProject in referencedProjects)
                            {
                                var refProjectName = refProject.GetType().Name;
                                string fullNameRefName = refProjectName + "-" + configuration + "-" + platform;
                                output.WriteLine(",");

                                //если добавить зависимость на -in то в линковщик придет пачка объектников, а не либа (поэтому зависимость на -dll)
                                output.Write("                 \"" + fullNameRefName + "-dll\"");
                            }

                            output.WriteLine(" }");

                            output.WriteLine("  .LinkerOutput = '$Out$\\{0}.{1}'", projectName, isExecutable ? "exe" : "dll");

                            switch(project.applicationKind)
                            {
                                case ApplicationKind.SHARED_LIBRARY:
                                    {
                                        output.WriteLine("  .LinkerOptions + ' /DLL'                                                               ; Create DLL");
                                        output.WriteLine("                 + ' /SUBSYSTEM:WINDOWS'                                                 ; Subsystem: Windows");
                                        output.WriteLine("                 + ' /IMPLIB:\"$Temp$\\{0}.lib\"'", projectName);
                                        output.WriteLine("                 + ' /PDB:\"$Out$\\{0}.pdb\"'", projectName);
                                        output.WriteLine("                 + ' /DEF:\"$Temp$\\{0}.def\"'", projectName);
                                        output.WriteLine("                 + ' /DEFGEN'");
                                        break;
                                    }

                                case ApplicationKind.CONSOLE_APPLICATION:
                                    {
                                        output.WriteLine("  .LinkerOptions + ' /SUBSYSTEM:CONSOLE'                                                  ; Subsystem: Console");
                                        output.WriteLine("                 + ' /IGNORE:4001'                                                        ; Don't complain about linking libs only");
                                        break;
                                    }

                                case ApplicationKind.WINDOWED_APPLICATION:
                                    {
                                        output.WriteLine("  .LinkerOptions + ' /SUBSYSTEM:WINDOWS'                                                  ; Subsystem: Windows");
                                        output.WriteLine("                 + ' /IGNORE:4001'                                                        ; Don't complain about linking libs only");
                                        output.WriteLine("                 + ' /ENTRY:WinMain@16'                                                   ; Entry point");
                                        break;
                                    }
                            }


                            SortedSet<string> librariesDirs = project.LibrariesDirs;
                            foreach (string libPath in librariesDirs)
                            {
                                output.WriteLine("                 + ' /LIBPATH:\"{0}\"'", Utilites.FixupSlashes(workSpace.ResolveMacroVariables(libPath)).TrimEnd('/', '\\'));
                            }

                            SortedSet<string> libraries = project.LibrariesWithoutExt;
                            foreach (string library in libraries)
                            {
                                output.WriteLine("                 + ' \"{0}\"'", Utilites.FixupSlashes(workSpace.ResolveMacroVariables(library)) + ".lib");
                            }

                            output.WriteLine("}");
                            output.WriteLine("");
                        }


                        string alias = "Alias( '" + fullName + "' ) { .Targets = { '" + nameForAlias + "' } }";
                        output.WriteLine(alias);
                        output.WriteLine("");

                    }

                    output.Flush();

                    var bffFileName = location + projectName + ".bff";
                    Utilites.SaveFileIfChanged(bffFileName, memoryStream);
                }
            }
            #endregion
            return true;
		}

		public bool BeforeBuild( Workspace workSpace )
		{
			return true;
		}

		public bool AfterBuild( Workspace workSpace, Dictionary<Type, List<ProjectFile>> projectConfigurations )
		{
			return true;
		}

		public bool BuildSolution( Workspace workSpace, SolutionFile solution, Dictionary<Type, List<ProjectFile>> projectConfigurations )
		{
            GenerateCompilerSettings();

			var solutionName = solution.GetType().Name;


            Log.Info(string.Format("Solution : {0}", solution.GetName()));
            Log.Info("Build file list and dependencies");

            ProjectSorter sorter = new ProjectSorter();
            foreach (var projects in projectConfigurations)
            {
                var location = Utilites.FixupSlashes(workSpace.ResolveMacroVariables(projects.Value[0].location));

                ProjectFile project = projects.Value[0];

                //пока только C++ проекты
                if (HaveSourceFilesToBuild(projects.Value, location) && project.language == Language.CPP && project.applicationKind != ApplicationKind.UTILITY)
                {
                    sorter.Add(project);
                }
                else
                {
                    Log.Info(string.Format("skip {0}", projects.Value[0].GetType().Name));
                }
            }

            Log.Info("Done.");


            List<ProjectFile> sortedProjects = sorter.SortedProjects;

            #region
            using (var memoryStream = new MemoryStream())
            {
                using (var output = new StreamWriter(memoryStream))
                {
                    output.WriteLine("; autogenerated fasbuild solution");
                    output.WriteLine("");

                    output.WriteLine(".Root = \"{0}\"", Utilites.GetTargetDirectory().TrimEnd('/', '\\'));
                    output.WriteLine("");


                    output.WriteLine("#include \"vs2010.bff\"");
                    output.WriteLine("");

                    output.WriteLine("; projects");
                    foreach (var project in sortedProjects)
                    {
                        var projFullPath = GetProjectFullPath(workSpace, project);
                        var projRelativePath = Utilites.RelativePath(Utilites.GetTargetDirectory(), workSpace.ResolveMacroVariables(projFullPath));

                        output.WriteLine("#include \"{0}\"", projRelativePath);
                    }
                    output.WriteLine("");



                    foreach (var platform in solution.Platforms)
                    {
                        foreach (var configuration in solution.Configurations)
                        {
                            string configurationName = Utilites.GetConfigurationName(configuration);
                            string platformName = Utilites.GetPlatformName(platform);

                            output.WriteLine("Alias( '{0}-{1}' )", configurationName, platformName);
                            output.WriteLine("{");
                            output.WriteLine("  .Targets = {");

                            for (int i = 0; i < sortedProjects.Count; i++ )
                            {
                                ProjectFile project = sortedProjects[i];
                                string projectName = project.GetType().Name;
                                string fullName = projectName + "-" + configurationName + "-" + platformName;

                                if ((i + 1) < sortedProjects.Count)
                                {
                                    output.WriteLine("    '{0}',", fullName);
                                } else
                                {
                                    output.WriteLine("    '{0}'", fullName);
                                }
                            }

                            output.WriteLine("  }");
                            output.WriteLine("}");
                        }
                    }

                    output.WriteLine("");
                    
                    output.Flush();

                    var fileName = Utilites.GetTargetDirectory() + solutionName + ".bff";
                    Utilites.SaveFileIfChanged(fileName, memoryStream);
                }
            }
            #endregion



            return true;
		}

	}
}